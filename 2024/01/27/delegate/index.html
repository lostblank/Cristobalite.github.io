<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Shigure</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="委托 什么是委托  委托（delegate）是函数指针的升级版  一切皆地址  变量（数据）是某个地址为起点的一段内存中存储的值 函数（算法）是某个地址为起点的一段内存中所存储的一组机器语言指令   直接调用与间接调用  直接调用：通过函数名来调用函数，CPU通过函数名直接获得函数所在地址并开始执行——返回 间接调用：通过函数指针来调用函数，CPU通过读取函数指针存储的值获得函数所在地址并开始执行">
<meta property="og:type" content="article">
<meta property="og:title" content="Shigure">
<meta property="og:url" content="https://github.com/lostblank/Cristobalite.github.io.git/2024/01/27/delegate/index.html">
<meta property="og:site_name" content="Shigure">
<meta property="og:description" content="委托 什么是委托  委托（delegate）是函数指针的升级版  一切皆地址  变量（数据）是某个地址为起点的一段内存中存储的值 函数（算法）是某个地址为起点的一段内存中所存储的一组机器语言指令   直接调用与间接调用  直接调用：通过函数名来调用函数，CPU通过函数名直接获得函数所在地址并开始执行——返回 间接调用：通过函数指针来调用函数，CPU通过读取函数指针存储的值获得函数所在地址并开始执行">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2024/01/25/7m9gXARM4iPL1Qf.png">
<meta property="article:published_time" content="2024-01-27T12:52:24.533Z">
<meta property="article:modified_time" content="2024-01-27T08:51:34.123Z">
<meta property="article:author" content="Shigure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/01/25/7m9gXARM4iPL1Qf.png">
  
    <link rel="alternate" href="/lostblank/Cristobalite.github.io.git/atom.xml" title="Shigure" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/lostblank/Cristobalite.github.io.git/favicon.png">
  
  
  
<link rel="stylesheet" href="/lostblank/Cristobalite.github.io.git/css/style.css">

  
    
<link rel="stylesheet" href="/lostblank/Cristobalite.github.io.git/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/lostblank/Cristobalite.github.io.git/" id="logo">Shigure</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/lostblank/Cristobalite.github.io.git/" id="subtitle">Wellcom to Shigure blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/lostblank/Cristobalite.github.io.git/">Home</a>
        
          <a class="main-nav-link" href="/lostblank/Cristobalite.github.io.git/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/lostblank/Cristobalite.github.io.git/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/lostblank/Cristobalite.github.io.git"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-delegate" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/lostblank/Cristobalite.github.io.git/2024/01/27/delegate/" class="article-date">
  <time class="dt-published" datetime="2024-01-27T12:52:24.533Z" itemprop="datePublished">2024-01-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><ol>
<li><p>什么是委托</p>
<ul>
<li><p>委托（delegate）是函数指针的升级版</p>
</li>
<li><p>一切皆地址</p>
<ul>
<li>变量（数据）是某个地址为起点的一段内存中存储的值</li>
<li>函数（算法）是某个地址为起点的一段内存中所存储的一组机器语言指令</li>
</ul>
</li>
<li><p>直接调用与间接调用</p>
<ul>
<li>直接调用：通过函数名来调用函数，CPU通过函数名直接获得函数所在地址并开始执行——返回</li>
<li>间接调用：通过函数指针来调用函数，CPU通过读取函数指针存储的值获得函数所在地址并开始执行——返回</li>
</ul>
</li>
<li><p>Java中没有与委托相对应的功能实体</p>
</li>
<li><p>委托的简单使用</p>
<ul>
<li><p>Action委托</p>
</li>
<li><pre><code class="c#">namespace func
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            Calculator calculator = new Calculator();
            Action action = new Action(calculator.Report);
            calculator.Report();				//直接调用，不使用Action委托
            action.Invoke();						//使用Action委托进行间接调用
            action();									//使用Action的简便写法
        &#125;

        class Calculator
        &#123;
            public void Report()
            &#123;
                Console.WriteLine(&quot;hello!&quot;);
            &#125;
        &#125;
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* Func委托</span><br><span class="line"></span><br><span class="line">* ```C#</span><br><span class="line">  namespace func</span><br><span class="line">  &#123;</span><br><span class="line">      class Program</span><br><span class="line">      &#123;</span><br><span class="line">          static void Main(string[] args)</span><br><span class="line">          &#123;       </span><br><span class="line">              Func&lt;int, int, int&gt; func1 = new Func&lt;int, int, int&gt;(calculator.Add);		//Func属于泛型</span><br><span class="line">              Func&lt;int, int, int&gt; func2 = new Func&lt;int, int, int&gt;(calculator.Sub);</span><br><span class="line">  </span><br><span class="line">              int x = 100;</span><br><span class="line">              int y = 200;</span><br><span class="line">              int z = 0;</span><br><span class="line">              z = func1.Invoke(x, y);				//间接调用，也可以使用上面的简便写法</span><br><span class="line">              Console.WriteLine(z);</span><br><span class="line">              z = func2.Invoke(x, y);</span><br><span class="line">              Console.WriteLine(z);</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          class Calculator</span><br><span class="line">          &#123;          </span><br><span class="line">              public int Add(int x,int y)</span><br><span class="line">              &#123;</span><br><span class="line">                  int result= x + y;</span><br><span class="line">                  return result;</span><br><span class="line">              &#125;</span><br><span class="line">  </span><br><span class="line">              public int Sub(int x, int y)</span><br><span class="line">              &#123;</span><br><span class="line">                  int result = x - y;</span><br><span class="line">                  return result;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>委托的声明（自定义）</p>
<ul>
<li><p>委托是一种类（class），类是数据类型所以委托也是一种数据类型</p>
</li>
<li><p>它的声明方式和一般类不同</p>
</li>
<li><p>注意声明委托的问题</p>
<ul>
<li>避免写错地方结果声明成嵌套类型</li>
<li>与program平行 ，声明在名称空间里面</li>
</ul>
</li>
<li><p>委托与所封装的方法必需“类型兼容”</p>
<ul>
<li>返回值的数据类型一致</li>
<li>参数列表在个数和数据类型上一致（参数名不需要一样）</li>
<li><img src="https://s2.loli.net/2024/01/25/7m9gXARM4iPL1Qf.png" alt="image-20240125165659404" style="zoom: 67%;" /></li>
</ul>
</li>
<li><pre><code class="C#">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace weituo
&#123;
    public delegate double Calc(double x, double y);		//声明委托Calc ，double类型，两个double类型的参数
  
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            Calculator calculator = new Calculator();
            Calc calc1 = new Calc(calculator.Add);
            Calc calc2 = new Calc(calculator.Sub);

            double x = 100;
            double y = 200;
            double z = 0;

            z= calc1.Invoke(x, y);
            Console.WriteLine(z);
            z = calc2(x, y);
            Console.WriteLine(z);
           //Console.WriteLine(calc1.Invoke(100, 200));
           //Console.WriteLine(calc2(200, 300));
            
        &#125;

        class Calculator
        &#123;
            public double Add(double x, double y)
            &#123;
                return x + y;
            &#125;
            public double Sub(double x, double y)
            &#123;
                return x - y;
            &#125;
        &#125;
        
    &#125;
&#125;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 委托的一般使用</span><br><span class="line"></span><br><span class="line">   * 把方法当做参数传给另一个方法</span><br><span class="line">     * 模板方法：借用指定外部方法来产生结果</span><br><span class="line">       * 相当于填空题</span><br><span class="line">       * 常位于代码中部</span><br><span class="line">       * 委托有返回值</span><br><span class="line">       * Reuse，复用，可以提高工作效率减少bug的引入</span><br><span class="line">       * ```C#</span><br><span class="line">         using System;</span><br><span class="line">         </span><br><span class="line">         namespace mobanweituo</span><br><span class="line">         &#123;</span><br><span class="line">             class Program</span><br><span class="line">             &#123;</span><br><span class="line">                 static void Main(string[] args)</span><br><span class="line">                 &#123;</span><br><span class="line">                     // 创建ProductFactory和WrapFactory的实例</span><br><span class="line">                     ProductFactory productFactory = new ProductFactory();</span><br><span class="line">                     WrapFactory wrapFactory = new WrapFactory();</span><br><span class="line">         </span><br><span class="line">                     // 定义创建不同产品（Pizza和Car）的函数</span><br><span class="line">                     Func&lt;Product&gt; func1 = new Func&lt;Product&gt;(productFactory.MakePizza);</span><br><span class="line">                     Func&lt;Product&gt; func2 = new Func&lt;Product&gt;(productFactory.MakeCar);</span><br><span class="line">         </span><br><span class="line">                     // 使用WrapFactory包装产品</span><br><span class="line">                     Box box1 = wrapFactory.WrapProduct(func1);</span><br><span class="line">                     Box box2 = wrapFactory.WrapProduct(func2);</span><br><span class="line">         </span><br><span class="line">                     // 显示盒子中产品的名称</span><br><span class="line">                     Console.WriteLine(box1.Product.Name);</span><br><span class="line">                     Console.WriteLine(box2.Product.Name);</span><br><span class="line">                 &#125;</span><br><span class="line">         </span><br><span class="line">                 // 表示一个产品</span><br><span class="line">                 class Product</span><br><span class="line">                 &#123;</span><br><span class="line">                     public string Name &#123; get; set; &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">         </span><br><span class="line">                 // 表示包含产品的盒子</span><br><span class="line">                 class Box</span><br><span class="line">                 &#123;</span><br><span class="line">                     public Product Product &#123; get; set; &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">         </span><br><span class="line">                 // 用于将产品包装在盒子中的工厂，模板方法</span><br><span class="line">                 class WrapFactory</span><br><span class="line">                 &#123;</span><br><span class="line">                     public Box WrapProduct(Func&lt;Product&gt; getProduct)</span><br><span class="line">                     &#123;</span><br><span class="line">                         // 创建一个新的盒子并将产品包装在内</span><br><span class="line">                         Box box = new Box();</span><br><span class="line">                         Product product = getProduct.Invoke();</span><br><span class="line">                         box.Product = product;</span><br><span class="line">                         return box;</span><br><span class="line">                     &#125; </span><br><span class="line">                 &#125;</span><br><span class="line">         </span><br><span class="line">                 // 用于创建不同产品（Pizza和Car）的工厂</span><br><span class="line">                 class ProductFactory</span><br><span class="line">                 &#123;</span><br><span class="line">                     public Product MakePizza()</span><br><span class="line">                     &#123;</span><br><span class="line">                         // 创建一个Pizza产品</span><br><span class="line">                         Product product = new Product();</span><br><span class="line">                         product.Name = &quot;Pizza&quot;;</span><br><span class="line">                         return product;</span><br><span class="line">                     &#125;</span><br><span class="line">         </span><br><span class="line">                     public Product MakeCar()</span><br><span class="line">                     &#123;</span><br><span class="line">                         // 创建一个Car产品</span><br><span class="line">                         Product product = new Product();</span><br><span class="line">                         product.Name = &quot;Car&quot;;</span><br><span class="line">                         return product;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br></pre></td></tr></table></figure>
  
    
  
* 回调（callback）方法：调用指定的外部方法
  * 相当于流水线 
  
  * 常位于代码末尾
  
  * 委托无返回值
  
  * 用委托封装一个外部方法，再通过委托传到方法内部，实现间接调用
  
  * ```c#
    using System;
    
    namespace huidiao
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                // 创建ProductFactory和WrapFactory的实例
                ProductFactory productFactory = new ProductFactory();
                WrapFactory wrapFactory = new WrapFactory();
    
                // 定义创建不同产品（Pizza和Car）的函数
                Func&lt;Product&gt; func1 = new Func&lt;Product&gt;(productFactory.MakePizza);
                Func&lt;Product&gt; func2 = new Func&lt;Product&gt;(productFactory.MakeCar);
    
                // 创建Logger实例
                Logger logger = new Logger();
                // 定义记录日志的委托
                Action&lt;Product&gt; log = new Action&lt;Product&gt;(logger.Log);
    
                // 使用WrapFactory包装产品，并在价格大于等于50时记录日志
                Box box1 = wrapFactory.WrapProduct(func1, log);
                Box box2 = wrapFactory.WrapProduct(func2, log);
    
                // 显示盒子中产品的名称
                Console.WriteLine(box1.Product.Name);
                Console.WriteLine(box2.Product.Name);
            &#125;
    
            // 日志记录器类
            class Logger
            &#123;
                // 记录产品日志的方法
                public void Log(Product product)
                &#123;
                    Console.WriteLine(&quot;产品&#39;&#123;0&#125;&#39;在 &#123;1&#125; 创建。价格为 &#123;2&#125;&quot;, product.Name, DateTime.UtcNow, product.Price);
                &#125;
            &#125;
    
            // 产品类
            class Product
            &#123;
                public string Name &#123; get; set; &#125;
                public double Price &#123; get; set; &#125;
            &#125;
    
            // 包含产品的盒子类
            class Box
            &#123;
                public Product Product &#123; get; set; &#125;
            &#125;
    
            // 将产品包装在盒子中的工厂类
            class WrapFactory
            &#123;
                // 包装产品并在价格大于等于50时触发日志回调
                public Box WrapProduct(Func&lt;Product&gt; getProduct, Action&lt;Product&gt; logCallback)
                &#123;
                    Box box = new Box();
                    Product product = getProduct.Invoke();
                    
                    // 如果产品的价格大于等于50，则记录日志
                    if (product.Price &gt;= 50)
                    &#123;
                        logCallback(product);
                    &#125;
    
                    box.Product = product;
                    return box;
                &#125;
            &#125;
    
            // 创建不同产品（Pizza和Car）的工厂类
            class ProductFactory
            &#123;
                // 创建Pizza产品的方法
                public Product MakePizza()
                &#123;
                    Product product = new Product();
                    product.Name = &quot;Pizza&quot;;
                    product.Price = 55;
                    return product;
                &#125;
    
                // 创建Car产品的方法
                public Product MakeCar()
                &#123;
                    Product product = new Product();
                    product.Name = &quot;Car&quot;;
                    product.Price = 100;
                    return product;
                &#125;
            &#125;
        &#125;
    &#125;
    
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">  * 缺点</span><br><span class="line">    1. 这是一种方法级别的紧耦合，现实工作中要谨慎使用</span><br><span class="line">    2. 使可读性下降，debug难度增加</span><br><span class="line">    3. 把委托回调，异步调用和多线程纠缠在一起，会让代码变得难以阅读和维护</span><br><span class="line">    4. 委托使用不当有可能造成内存泄露和程序性能下降</span><br><span class="line"></span><br><span class="line"># 委托的高级使用</span><br><span class="line"></span><br><span class="line">1. 多播委托（multicast）</span><br><span class="line"></span><br><span class="line">2.    示例</span><br><span class="line"></span><br><span class="line">   ```C#</span><br><span class="line">   using System;</span><br><span class="line">   using System.Collections.Generic;</span><br><span class="line">   using System.Linq;</span><br><span class="line">   using System.Text;</span><br><span class="line">   using System.Threading.Tasks;</span><br><span class="line">   </span><br><span class="line">   namespace WeituoPro</span><br><span class="line">   &#123;</span><br><span class="line">       class Program</span><br><span class="line">       &#123;</span><br><span class="line">           static void Main(string[] args)</span><br><span class="line">           &#123;</span><br><span class="line">               Student student1 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Yellow &#125;;</span><br><span class="line">               Student student2 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Red &#125;;</span><br><span class="line">               Student student3 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Green &#125;;</span><br><span class="line">   </span><br><span class="line">               Action action1 = new Action(student1.DoHomework);</span><br><span class="line">               Action action2 = new Action(student2.DoHomework);</span><br><span class="line">               Action action3 = new Action(student3.DoHomework);</span><br><span class="line">   </span><br><span class="line">               action1 += action2;</span><br><span class="line">               action1 += action3;</span><br><span class="line">               action1.Invoke();					//使用一个委托封装多个方法，多播委托，调用时执行顺序按照封装顺序执行</span><br><span class="line">             </span><br><span class="line">             	//action1.Invoke();				单播委托</span><br><span class="line">               //action2.Invoke();</span><br><span class="line">               //action3.Invoke();</span><br><span class="line">           &#125;</span><br><span class="line">            </span><br><span class="line">           class Student</span><br><span class="line">           &#123;</span><br><span class="line">               public int ID &#123; get; set; &#125;</span><br><span class="line">               public ConsoleColor PenColor &#123; get; set; &#125;</span><br><span class="line">   </span><br><span class="line">               public void DoHomework()</span><br><span class="line">               &#123;</span><br><span class="line">                   for (int i = 0; i &lt; 5; i++)</span><br><span class="line">                   &#123;</span><br><span class="line">                       Console.ForegroundColor = this.PenColor;</span><br><span class="line">                       Console.WriteLine(&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;,this.ID,i);</span><br><span class="line">                       Task.Delay(1000).Wait();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<ol start="2">
<li><p>隐式异步调用</p>
<ul>
<li><p>同步与异步的简介</p>
<ul>
<li>中英文语言差异</li>
<li>同步：你做完了（在你的基础上）我接着做</li>
<li>异步：咱们两个同时做（相当于汉语中的同步进行）</li>
</ul>
</li>
<li><p>同步调用与异步调用的对比</p>
<ul>
<li>每一个运行的程序是一个进程（process）</li>
<li>每个进程可以有一个或者多个进程（thread）</li>
<li>同步调用是在同一线程内</li>
<li>异步调用的底层机理是多线程</li>
<li>串行——同步——单线程</li>
<li>并行——异步——多线程</li>
<li>直接同步调用就是直接调用方法，使用委托则是间接同步调用，多播委托也属于同步调用</li>
</ul>
</li>
<li><p>隐式多线程与显示多线程</p>
<ul>
<li><p>直接同步调用：使用方法名</p>
</li>
<li><p>间接同步调用：使用单播&#x2F;多播委托的Invoke方法</p>
</li>
<li><p>隐式异步调用：使用委托的BeginInvoke</p>
</li>
<li><p>显式异步调用：使用Thread或者Task</p>
</li>
<li><p>示例</p>
</li>
<li><p>隐式异步调用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WeituoPro</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student student1 = <span class="keyword">new</span> Student() &#123; ID = <span class="number">1</span>, PenColor = ConsoleColor.Yellow &#125;;</span><br><span class="line">            Student student2 = <span class="keyword">new</span> Student() &#123; ID = <span class="number">1</span>, PenColor = ConsoleColor.Red &#125;;</span><br><span class="line">            Student student3 = <span class="keyword">new</span> Student() &#123; ID = <span class="number">1</span>, PenColor = ConsoleColor.Green &#125;;</span><br><span class="line"></span><br><span class="line">            Action action1 = <span class="keyword">new</span> Action(student1.DoHomework);</span><br><span class="line">            Action action2 = <span class="keyword">new</span> Action(student2.DoHomework);</span><br><span class="line">            Action action3 = <span class="keyword">new</span> Action(student3.DoHomework);</span><br><span class="line"></span><br><span class="line">            action1.BeginInvoke(<span class="literal">null</span>, <span class="literal">null</span>);			<span class="comment">//单播隐式异步调用，但是多个线程在访问同一个资源时会发生资源冲突问题</span></span><br><span class="line">            action2.BeginInvoke(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            action3.BeginInvoke(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.ForegroundColor = ConsoleColor.Blue;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;test &#123;0&#125;&quot;</span>,i);</span><br><span class="line">                Task.Delay(<span class="number">1000</span>).Wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> ConsoleColor PenColor &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoHomework</span>()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.ForegroundColor = <span class="keyword">this</span>.PenColor;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;</span>,<span class="keyword">this</span>.ID,i);</span><br><span class="line">                    Task.Delay(<span class="number">1000</span>).Wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>显式异步调用</p>
</li>
<li><pre><code class="C#">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WeituoPro
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            Student student1 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Yellow &#125;;
            Student student2 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Red &#125;;
            Student student3 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Green &#125;;

            Action action1 = new Action(student1.DoHomework);
            Action action2 = new Action(student2.DoHomework);
            Action action3 = new Action(student3.DoHomework);

            Task task1 = new Task(new Action(student1.DoHomework));
            Task task2 = new Task(new Action(student2.DoHomework));
            Task task3 = new Task(new Action(student3.DoHomework));

            task1.Start();
            task2.Start();
            task3.Start();

            for (int i = 0; i &lt; 5; i++)
            &#123;
                Console.ForegroundColor = ConsoleColor.Blue;
                Console.WriteLine(&quot;test &#123;0&#125;&quot;,i);
                Task.Delay(1000).Wait();
            &#125;
        &#125;
         
        class Student
        &#123;
            public int ID &#123; get; set; &#125;
            public ConsoleColor PenColor &#123; get; set; &#125;

            public void DoHomework()
            &#123;
                for (int i = 0; i &lt; 5; i++)
                &#123;
                    Console.ForegroundColor = this.PenColor;
                    Console.WriteLine(&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;,this.ID,i);
                    Task.Delay(1000).Wait();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>应该适时地使用接口（interface）取代一些对委托的使用</p>
<ul>
<li>Java完全地使用接口取代了委托的功能，即Java没有与C#中委托相对应的功能实体</li>
</ul>
</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/lostblank/Cristobalite.github.io.git/2024/01/27/delegate/" data-id="clrw393dj0000mkuebayvfuu0" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/lostblank/Cristobalite.github.io.git/2024/01/27/test/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          test
        
      </div>
    </a>
  
  
    <a href="/lostblank/Cristobalite.github.io.git/2024/01/27/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Shigure</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/lostblank/Cristobalite.github.io.git/archives/2024/01/">January 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/lostblank/Cristobalite.github.io.git/2024/01/27/test/">test</a>
          </li>
        
          <li>
            <a href="/lostblank/Cristobalite.github.io.git/2024/01/27/delegate/">(no title)</a>
          </li>
        
          <li>
            <a href="/lostblank/Cristobalite.github.io.git/2024/01/27/hello-world/">Shigure</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Shigure<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/lostblank/Cristobalite.github.io.git/" class="mobile-nav-link">Home</a>
  
    <a href="/lostblank/Cristobalite.github.io.git/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/lostblank/Cristobalite.github.io.git/js/jquery-3.6.4.min.js"></script>



  
<script src="/lostblank/Cristobalite.github.io.git/fancybox/jquery.fancybox.min.js"></script>




<script src="/lostblank/Cristobalite.github.io.git/js/script.js"></script>





  </div>
</body>
</html>