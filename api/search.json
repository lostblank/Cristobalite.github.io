[{"id":"641632e2596cda11898ff146651ae4ce","title":"SQLSever基础","content":"SqlSever基础建库使用ssms建立数据库主要数据文件：*.mdf\n日志文件：*.ldf\n次要数据文件：*.ndf\n使用sql语句建立数据库使用创建关键字create\n1create database name --此语句采用的是默认方式\n\n\n\n\n建表使用ssms建表注意列名，数据类型和null\n使用sql语句建表123456create table name --创建表（son char(4), --列名为son ，数据类型为char，长度为4sage int,ssex char(2)）\n\n删除表使用 drop table name命令\n\n主键和我外键定义关系型数据库中一条记录有多个属性，若其中某一个属性组能唯一表示一条记录，该属性组就可以成为主键\n当一个属性可以作为唯一标识使用时则该属性为主键，当一个属性不足以作为唯一标识时，则通过与其他属性组合成为属性组进行标识，该属性组作为主键\n当一个属性非自身表（a）的主键时又与其他表(b)相对应并且是该表的主键，则a表中的该属性是b表的外键\n作用维护数据库的完整性主键是确定一条记录的唯一标识\n外键用于与另一张表的关联；能确定另一张表记录的字段，用于保持数据的一致性\n约束作用外键取值规则：\n\n插入非空值时，如果主键表中没有这个值，则不能插入\n更新时，不能改为主键表中没有的值\n删除主键表记录时，你可以在建外键时选定外键记录一起级联删除还是拒绝删除\n更新主键记录时，同样有级联更新和拒绝执行的选择\n\n区别\n使用sql语句设置主键使用primary key设置主键\n123456create table name -- 创建表（son char(4) primary key, -- 列名为son ，数据类型为char，长度为4,并设置主键sage int,ssex char(2)）\n\n外键使用ssms设置外键选中表——右键——设计——关系——添加表和列表规范——选择对应表和列——完成\n新建数据关系图——选择对应表\n使用sql语句设置外键123456create table sc  -- 创建表sc(sno char(4) foreign key references student(sno),  -- 加外键约束cno char(4) foreign key references course(cno),  -- 加外键约束grade int,primary key(sno, cno)  -- 设置sno和cno的属性组为主键)\n\n再建立数据关系图即可\n为已存在的表设置主键123alter table studentadd constraint PK_snoprimary key (sno)\n\n为已存在的表设置外键1alter table sc add constraint FK_sno foreign key (sno) references student(sno)\n\n\n增使用ssms编辑\n使用sql语句添加添加单条数据使用 insert into\n1insert into student values(&#x27;01&#x27;,&#x27;张三&#x27;,&#x27;男&#x27;,&#x27;计算机学院&#x27;)\n\n添加多条数据使用union关键字\n12345insert into student(sno, sname, sage, ssex, sdept)select &#x27;0001&#x27;, &#x27;张三&#x27;, 18, &#x27;男&#x27;, &#x27;文学院&#x27; unionselect &#x27;0002&#x27;, &#x27;李四&#x27;, 19, &#x27;女&#x27;, &#x27;理学院&#x27; unionselect &#x27;0003&#x27;, &#x27;王五&#x27;, 20, &#x27;男&#x27;, &#x27;文学院&#x27; unionselect &#x27;0004&#x27;, &#x27;赵六&#x27;, 21, &#x27;女&#x27;, &#x27;理学院&#x27;\n\n通过其他表导入插入的表不存在时\n12-- 把表student中性别为&#x27;男&#x27;的学生信息插入到表student_back（不存在）中select * into student_back from student where ssex=&#x27;男&#x27;\n\n插入的表已存在\n1234-- 把表student中性别为&#x27;女&#x27;的学生信息插入到表student_back（已存在）中insert into student_back(bno, bname, bage, bsex, bdept)select sno, sname, sage, ssex, sdept from studentwhere ssex=&#x27;女&#x27;\n\n通过Excel导入可以使用任务重的导入数据\n\n删通过ssms删除选中表——编辑前200行，删除\n右键删除整个表，带数据一起删除，不过要注意表有没有外键约束，有的话不能直接删除主表，必须先删除子表再删除主表\n通过sql语句删除删除单行\n1DELETE FROM 表名称 WHERE 列名称 = 值\n\n删除所有行\n1DELETE FROM table_name\n\n删除表中的索引\n1DROP INDEX table_name.index_name\n\n删除表（结构、属性、索引都会删除）\n1DROP TABLE 表名称\n\n删除数据库\n1DROP DATABASE 数据库名称\n\n仅删除表内数据\n1TRUNCATE TABLE 表名称\n\n\n改通过sql语句修改数据修改单列数据\n1UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值\n\n修改多列数据\n12update student set ssex = &#x27;男&#x27;, sdept = &#x27;文学院&#x27;where sno = &#x27;0007&#x27;\n\n\n查select…from…*****  与 Top num\n1234select * from student-- &quot;*&quot;代表选择所有，即查询student表中的所有数据select Top 5 * from student-- &quot;Top num&quot;代表选择前num行，即查询student表中的前num行数据\n\n查询指定列123select sno, snamefrom student-- 如果只想看student表中的学号和姓名列，那就只需要查询指定列\n\nIsnull函数：判断空值123select cno, cname, isnull(cpno, &#x27;&#x27;), ccreditfrom course-- isnull(cpno,&#x27;&#x27;)将cpno中的NULL值置空，用户就看不到NULL了，只能看见空白。但是列的名字会变为(No column name/无列名)\n\n使用 + 号12345select sno, sname as &#x27;姓名&#x27;,&#x27;学号是&#x27; + sno + &#x27;的同学叫&#x27; + sname +&#x27;.&#x27; as IDnamefrom student-- 使用&quot;+&quot;将两列进行合并-- 使用&quot;as&quot;将列名重命名\n\nasc（正序）1234select *from FactSalesQuotaorder by SalesAmountQuota-- 默认就是asc正序排序（从小到大）\n\ndesc（倒序）1234select *from FactSalesQuotaorder by EmployeeKey desc-- desc倒序排序（从大到小）\n\n其他用法1234select *from FactSalesQuotaorder by EmployeeKey desc, SalesAmountQuota-- 先按EmployeeKey倒序排序，如果EmployeeKey相同再按SalesAmountQuota排序\n\nwhere比较运算符123456789101112-- 比较运算符有 =、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;(&quot;&lt;&gt;&quot;是不等于的意思)select *from studentwhere sdept = &#x27;理学院&#x27;select *from studentwhere sage &gt;= 20select *from studentwhere ssex &lt;&gt; &#x27;男&#x27;\n\nor与and12345678910111213-- and就是两个条件都要满足，or就是满足一个条件即可-- and就是两个条件都要满足，or就是满足一个条件即可select *from studentwhere sdept = &#x27;理学院&#x27; and sage &gt;= 20select *from studentwhere sage &gt;= 20 or sno = &#x27;0001&#x27;select *from studentwhere ssex = &#x27;男&#x27; and ssex = &#x27;女&#x27;\n\nLike “%”和”_”通配符1234567-- like代表要模糊查找-- &quot;%&quot;代表任意符，表示可以有任何东西也可以没有-- &quot;_&quot;代表占位符，就是有且仅有一个字母，但是忘记了那个字母具体是什么select *from FactCallCenterwhere Shift like &#x27;AM&#x27;-- like&#x27;Shift&#x27;代表精确查找&#x27;AM&#x27;，相当于where Shift = &#x27;AM&#x27;\n\n12345select *from FactCallCenterwhere Shift like &#x27;PM%&#x27;-- like &#x27;PM%&#x27;代表以PM开头的所有字符串-- like &#x27;%PM&#x27;代表以PM结尾的所有字符串\n\n1234select *from FactCallCenterwhere Shift like &#x27;%M%&#x27;-- like &#x27;%M%&#x27;代表M前面和后面都可以有任何东西\n\n1234select *from FactCallCenterwhere Shift like &#x27;PM_&#x27;-- like &#x27;PM_&#x27;代表PM后面有且仅有一个字母或者数字，不能是空\n\nin和not in123select *from FactCallCenterwhere DateKey in (&#x27;20101101&#x27;, &#x27;20101105&#x27;, &#x27;20101110&#x27;)\n\n1234select *from FactCallCenterwhere WageType not in (&#x27;weekday&#x27;)-- 相当于where WageType &lt;&gt; &#x27;weekday&#x27;\n\nis null 和is not null1234567select *from DimProductwhere ProductSubcategoryKey is nullselect *from DimProductwhere ProductSubcategoryKey is not null\n\nbetween…and…选取介于两个值之间的数据范围，可以是数值，文本，或者日期\n123456789select *from FactCallCenterwhere DateKey between &#x27;20101105&#x27; and &#x27;20101107&#x27;-- DateKey在20101105-20101107范围内的所有数据-- 如果要取不在这个范围的则可以用以下语句select *from FactCallCenterwhere DateKey not between &#x27;20101105&#x27; and &#x27;20101107&#x27;\n\ngroup by &amp; having常用聚合函数 &amp; 经典查询语句\n常用函数有：count,Avg,Min,Max,Sum\n1234select count(*)from FactCallCenterwhere Shift = &#x27;AM&#x27;-- count用来统计符合条件的行数\n\n1234567selectAvg(LevelOneOperators) as AverageLevelOneOperators,Min(LevelOneOperators) as MinimumLevelOneOperators,Max(LevelOneOperators) as MaximumLevelOneOperators,Sum(LevelOneOperators) as SummaryLevelOneOperatorsfrom FactCallCenter-- Avg平均值，Min最小值，Max最大值，Sum求和\n\ngroup by &amp; having作用12345select Shift, Max(LevelOneOperators) as LevelOneOperators最大值from FactCallCenterwhere Shift is not nullgroup by Shift-- group by Shift表示对不同的Shift值，分别求LevelOneOperators的最大值\n\n1234567select Shift, Max(LevelOneOperators) as LevelOneOperators最大值from FactCallCenterwhere Shift is not nullgroup by Shifthaving Max(LevelOneOperators) &gt; 2-- group by Shift表示对不同的Shift值，分别求LevelOneOperators的最大值-- having Max(LevelOneOperators) &gt; 2 进一步对结果进行筛选\n\n","slug":"SqlSever","date":"2023-11-18T13:28:20.000Z","categories_index":"数据库","tags_index":"SqlSever","author_index":"时雨"},{"id":"9dbfb0ceb333a8d9adfdccfe0f20148d","title":"事件","content":"事件\n定义Event，事件，即 能够发生什么的什么事情\n角色事件是一种使对象或类能够提供通知的成员\n对象x拥有一个事件y ，想表达的思想是 ： 当事件y发生时，x有能力通知别的对象\n使用：用于对象或类间的动作协调与信息传递（消息推送）原理：事件模型（event model）中的两个 5发生——响应中的五个部分——闹钟响了你起床、孩子饿了你做饭。。。这里隐含这 订阅 关系\n发生——响应中的五个动作：\n\n我有一个事件\n一个人或者一群人关心我这个事件\n我的这个事件发生了\n关心这个事件的人会被依次通知到\n被通知到的人根据拿到的事件信息（又称事件数据、事件参数、通知）对事件进行响应（又称 处理事件）\n\n事件订阅者、事件参数\n提示\n事件多用于桌面、手机等开发的客户端编程、因为这些程序经常是用户通过事件来驱动的\n各种编程语言对这个机制的实现方法也不尽相同\nJava里面没有事件这种成员，也没有委托这种数据类型，Java的事件是通过接口来实现的\nMVC、MVP、MVVM等模式是事件模式更高级、更有效的玩法\n日常开发的时候，使用已有时间的机会比较多，自己声明事件的机会比较少\n事件的功能&#x3D;通知+可选的事件参数（即详细信息）\n\n\n事件的应用实例演示派生（继承）与扩展（extends）\n123456789101112131415161718192021222324252627282930313233343536using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace Event&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            // 创建 MyForm 对象            MyForm form = new MyForm();            // 订阅 Click 事件，当窗体单击时，调用 FormClicked 方法            form.Click += form.FormClicked;            // 显示窗体            form.ShowDialog();        &#125;        // 自定义窗体类，继承自 Form        class MyForm : Form        &#123;            // 事件处理方法，当窗体被单击时调用            internal void FormClicked(object sender, EventArgs e)            &#123;                // 将当前时间设置为窗体标题                this.Text = DateTime.Now.ToString();            &#125;        &#125;    &#125;&#125;\n\n\n\n事件模型的五个组成部分\n事件的拥有者（event source，对象）\n事件的成员（event ，成员）\n事件的响应者（event subscriber,对象）\n事件处理器（event handler,成员）——本质上是一个回调方法\n事件订阅器——把事件处理器与事件关联在一起，本质上是一种以委托类型为基础的“约定”\n\n注意\n事件处理器是方法成员\n挂接事件处理器的时候，可以使用委托实例，也可以直接使用方法名，这是个语法糖\n事件处理器对事件的订阅不是随意的，匹配与否声明事件时所使用的委托类型来检测\n事件可以同步调用也可以异步调用\n事件不会主动发生，一定是由事件拥有者的内部逻辑所触发的\n\n\n事件的声明完整声明\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139using System;using System.Threading.Tasks;namespace Event2&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            // 创建顾客对象和服务员对象            Customer customer = new Customer();            Waiter waiter = new Waiter();            // 顾客订阅服务员的处理方法            customer.Order += waiter.Action;            // 顾客开始用餐流程            customer.Action();            // 顾客支付账单            customer.PayTheBill();        &#125;     &#125;    // 订单事件参数类，用于传递点餐信息    public class OrderEventArgs : EventArgs    &#123;        public string DishName &#123; get; set; &#125; // 菜品名称        public string Size &#123; get; set; &#125; // 菜品大小    &#125;    // 订单事件处理委托    public delegate void OrderEventHandler(Customer customer, OrderEventArgs e);    // 顾客类    public class Customer    &#123;        private OrderEventHandler orderEventHandler;        //简略声明方法        //public event OrderEventHandler Order;        // 事件定义，用于处理订单        public event OrderEventHandler Order         &#123;            add            &#123;                this.orderEventHandler += value;            &#125;            remove            &#123;                this.orderEventHandler -= value;            &#125;        &#125;        public double Bill &#123; get; set; &#125; // 顾客账单        // 顾客支付账单的方法        public void PayTheBill()        &#123;            Console.WriteLine(&quot;I will pay $&#123;0&#125;&quot;, this.Bill);        &#125;        // 顾客进入餐厅的方法        public void Walkin()        &#123;            Console.WriteLine(&quot;Walk into the restaurant.&quot;);        &#125;        // 顾客坐下的方法        public void SitDown()        &#123;            Console.WriteLine(&quot;Sit down&quot;);        &#125;        // 顾客思考点餐的方法        public void Think()        &#123;            for (int i = 0; i &lt; 5; i++)            &#123;                Console.WriteLine(&quot;Let me think ...&quot;);                Task.Delay(1000).Wait();            &#125;            // 当顾客思考完毕后，通过事件通知服务员点餐            this.OnOrder(&quot;Chicken&quot;, &quot;large&quot;);        &#125;        // 触发订单事件的方法        protected void OnOrder(string dishName, string size)        &#123;            if (this.orderEventHandler != null)            &#123;                // 创建订单事件参数                OrderEventArgs e = new OrderEventArgs();                e.DishName = dishName;                e.Size = size;                                // 调用订阅的事件处理方法                this.orderEventHandler.Invoke(this, e);            &#125;        &#125;        // 顾客整个用餐过程的方法        public void Action()        &#123;            Console.ReadLine(); // 等待输入，模拟开始用餐            this.Walkin();            this.SitDown();            this.Think();        &#125;    &#125;    // 服务员类    public class Waiter    &#123;        // 服务员处理订单的方法        public void Action(Customer customer, OrderEventArgs e)        &#123;            Console.WriteLine(&quot;I will serve you the dish - &#123;0&#125;&quot;, e.DishName);            double price = 10;            // 根据菜品大小调整价格            switch (e.Size)            &#123;                case &quot;small&quot;:                    price *= 0.5;                    break;                case &quot;large&quot;:                    price *= 1.5;                    break;                default:                    break;            &#125;            // 将价格添加到顾客的账单中            customer.Bill += price;        &#125;    &#125;&#125;\n\n简略声明（字段式声明，field-like）\n1public event OrderEventHandler Order;\n\n对应的触发事件时要更改为使用this.order.invoke();\n有了委托字段&#x2F;属性，为什么还需要事件为了程序的逻辑更加有道理，更加安全，谨防借刀杀人\n所以事件的本质是委托字段的一个包装器这个包装器对委托字段的访问起限制作用，相当于一个蒙板\n封装（encapsulation）的一个重要功能就是隐藏\n事件对外界隐藏了委托实例的大部分功能，仅暴露添加&#x2F;移除事件处理器的功能\n添加&#x2F;移除事件处理器的时候可以直接使用方法名，这是委托实例不具备的功能\n用于声明事件的委托类型的命名约定用于声明Foo事件的委托，一般命名为FooEventHandler（除非是一个非常通用的事件约束）\nFooEventHandler委托的参数一般有两个（由Win32API演化而来，历史悠久）\n\n第一个是object类型，名字为sender，实际上就是事件的拥有者，事件的source\n第二个是EventArgs类的派生类，类名一般为FooEventArgs，参数名为e，也就是事件参数\n虽然没有官方的说法，但我们可以把委托的参数列表看做是事件发生后发送给事件响应者的事件消息\n\n触发Foo事件的方法一般命名为OnFoo，即因何引发，事出有因\n\n访问级别为protected,不能为poublic，不然又可以借刀杀人了\n\n事件的命名约定带有时态的动词或者动词短语\n事件拥有者正在做什么事情，用进行时\n事件的拥有者做完了什么事情，用完成时\n注意命名使用EventArgs时记得要使用其派生基类EventArgs\n1public class OrderEventArgs:EventArgs\n\n委托类型不要声明到其他类中，委托是一个数据类型，尽可能不要使用嵌套，与类平级\n一起使用的类需要保证其访问级别一致\n事件与委托的关系事件真的是“以特殊方式声明的委托字段&#x2F;实例吗”不是！只是声明的时候看起来像\n事件声明的时候使用了委托类型，简化声明造成事件看上去像一个委托字段（实例），而event关键字则更像是一个修饰符\n订阅事件的时候+&#x3D;操作符后面是一个委托实例，这与委托实例的赋值方法语法相同，这也让事件看起来像是一个委托字段，事实上并不是这样\n事件的本质是加装在委托字段上的一个蒙板（mask），是个起掩蔽作用的包装器，这个用于阻挡非法操作的蒙板绝不是委托字段本身\n为什么要使用委托类型来声明事件站在source的角度来看，它是一种约定，是为了表明source能对外传递哪些消息\n站在subsceiber的角度来看，它是一种约定，是为了约束能够使用什么样签名的方法来处理（响应）事件\n委托类型的实例将用于存储（引用）事件处理器\n对比事件与属性属性不是字段——很多时候属性是字段的包装器，这个包装器用来保护字段不被滥用\n事件不是委托字段——它是委托字段的包装器，这个包装器来保护委托字段不被滥用\n包装器是永远都不可能被包装的东西\n","slug":"shijian","date":"2023-10-28T13:28:20.000Z","categories_index":"编程","tags_index":"C#","author_index":"时雨"},{"id":"c31509689845d3f9a7357a64a02fc66b","title":"委托","content":"委托\n什么是委托委托（delegate）是函数指针的升级版\n一切皆地址\n\n变量（数据）是某个地址为起点的一段内存中存储的值\n函数（算法）是某个地址为起点的一段内存中所存储的一组机器语言指令\n\n直接调用与间接调用\n\n直接调用：通过函数名来调用函数，CPU通过函数名直接获得函数所在地址并开始执行——返回\n间接调用：通过函数指针来调用函数，CPU通过读取函数指针存储的值获得函数所在地址并开始执行——返回\n\nJava中没有与委托相对应的功能实体\n委托的简单使用\nAction委托\n12345678910111213141516171819202122namespace func&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Calculator calculator = new Calculator();            Action action = new Action(calculator.Report);            calculator.Report();\t\t\t\t//直接调用，不使用Action委托            action.Invoke();\t\t\t\t\t\t//使用Action委托进行间接调用            action();\t\t\t\t\t\t\t\t\t//使用Action的简便写法        &#125;        class Calculator        &#123;            public void Report()            &#123;                Console.WriteLine(&quot;hello!&quot;);            &#125;        &#125;    &#125;&#125;\n\nFunc委托\n12345678910111213141516171819202122232425262728293031323334namespace func&#123;    class Program    &#123;        static void Main(string[] args)        &#123;                   Func&lt;int, int, int&gt; func1 = new Func&lt;int, int, int&gt;(calculator.Add);\t\t//Func属于泛型            Func&lt;int, int, int&gt; func2 = new Func&lt;int, int, int&gt;(calculator.Sub);            int x = 100;            int y = 200;            int z = 0;            z = func1.Invoke(x, y);\t\t\t\t//间接调用，也可以使用上面的简便写法            Console.WriteLine(z);            z = func2.Invoke(x, y);            Console.WriteLine(z);        &#125;        class Calculator        &#123;                      public int Add(int x,int y)            &#123;                int result= x + y;                return result;            &#125;            public int Sub(int x, int y)            &#123;                int result = x - y;                return result;            &#125;        &#125;    &#125;&#125;\n\n\n\n委托的声明（自定义）委托是一种类（class），类是数据类型所以委托也是一种数据类型\n它的声明方式和一般类不同\n注意声明委托的问题\n\n避免写错地方结果声明成嵌套类型\n与program平行 ，声明在名称空间里面\n\n委托与所封装的方法必需“类型兼容”\n\n返回值的数据类型一致\n\n参数列表在个数和数据类型上一致（参数名不需要一样）\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace weituo&#123;    public delegate double Calc(double x, double y);\t\t//声明委托Calc ，double类型，两个double类型的参数      class Program    &#123;        static void Main(string[] args)        &#123;            Calculator calculator = new Calculator();            Calc calc1 = new Calc(calculator.Add);            Calc calc2 = new Calc(calculator.Sub);            double x = 100;            double y = 200;            double z = 0;            z= calc1.Invoke(x, y);            Console.WriteLine(z);            z = calc2(x, y);            Console.WriteLine(z);           //Console.WriteLine(calc1.Invoke(100, 200));           //Console.WriteLine(calc2(200, 300));                    &#125;        class Calculator        &#123;            public double Add(double x, double y)            &#123;                return x + y;            &#125;            public double Sub(double x, double y)            &#123;                return x - y;            &#125;        &#125;            &#125;&#125;\n\n委托的一般使用把方法当做参数传给另一个方法\n模板方法：借用指定外部方法来产生结果\n相当于填空题\n常位于代码中部\n委托有返回值\nReuse，复用，可以提高工作效率减少bug的引入\n示例\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using System;namespace mobanweituo&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            // 创建ProductFactory和WrapFactory的实例            ProductFactory productFactory = new ProductFactory();            WrapFactory wrapFactory = new WrapFactory();            // 定义创建不同产品（Pizza和Car）的函数            Func&lt;Product&gt; func1 = new Func&lt;Product&gt;(productFactory.MakePizza);            Func&lt;Product&gt; func2 = new Func&lt;Product&gt;(productFactory.MakeCar);            // 使用WrapFactory包装产品            Box box1 = wrapFactory.WrapProduct(func1);            Box box2 = wrapFactory.WrapProduct(func2);            // 显示盒子中产品的名称            Console.WriteLine(box1.Product.Name);            Console.WriteLine(box2.Product.Name);        &#125;        // 表示一个产品        class Product        &#123;            public string Name &#123; get; set; &#125;        &#125;        // 表示包含产品的盒子        class Box        &#123;            public Product Product &#123; get; set; &#125;        &#125;        // 用于将产品包装在盒子中的工厂，模板方法        class WrapFactory        &#123;            public Box WrapProduct(Func&lt;Product&gt; getProduct)            &#123;                // 创建一个新的盒子并将产品包装在内                Box box = new Box();                Product product = getProduct.Invoke();                box.Product = product;                return box;            &#125;         &#125;        // 用于创建不同产品（Pizza和Car）的工厂        class ProductFactory        &#123;            public Product MakePizza()            &#123;                // 创建一个Pizza产品                Product product = new Product();                product.Name = &quot;Pizza&quot;;                return product;            &#125;            public Product MakeCar()            &#123;                // 创建一个Car产品                Product product = new Product();                product.Name = &quot;Car&quot;;                return product;            &#125;        &#125;    &#125;&#125;\n\n回调（callback）方法：调用指定的外部方法相当于流水线 \n常位于代码末尾\n委托无返回值\n用委托封装一个外部方法，再通过委托传到方法内部，实现间接调用\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697using System;namespace huidiao&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            // 创建ProductFactory和WrapFactory的实例            ProductFactory productFactory = new ProductFactory();            WrapFactory wrapFactory = new WrapFactory();            // 定义创建不同产品（Pizza和Car）的函数            Func&lt;Product&gt; func1 = new Func&lt;Product&gt;(productFactory.MakePizza);            Func&lt;Product&gt; func2 = new Func&lt;Product&gt;(productFactory.MakeCar);            // 创建Logger实例            Logger logger = new Logger();            // 定义记录日志的委托            Action&lt;Product&gt; log = new Action&lt;Product&gt;(logger.Log);            // 使用WrapFactory包装产品，并在价格大于等于50时记录日志            Box box1 = wrapFactory.WrapProduct(func1, log);            Box box2 = wrapFactory.WrapProduct(func2, log);            // 显示盒子中产品的名称            Console.WriteLine(box1.Product.Name);            Console.WriteLine(box2.Product.Name);        &#125;        // 日志记录器类        class Logger        &#123;            // 记录产品日志的方法            public void Log(Product product)            &#123;                Console.WriteLine(&quot;产品&#x27;&#123;0&#125;&#x27;在 &#123;1&#125; 创建。价格为 &#123;2&#125;&quot;, product.Name, DateTime.UtcNow, product.Price);            &#125;        &#125;        // 产品类        class Product        &#123;            public string Name &#123; get; set; &#125;            public double Price &#123; get; set; &#125;        &#125;        // 包含产品的盒子类        class Box        &#123;            public Product Product &#123; get; set; &#125;        &#125;        // 将产品包装在盒子中的工厂类        class WrapFactory        &#123;            // 包装产品并在价格大于等于50时触发日志回调            public Box WrapProduct(Func&lt;Product&gt; getProduct, Action&lt;Product&gt; logCallback)            &#123;                Box box = new Box();                Product product = getProduct.Invoke();                                // 如果产品的价格大于等于50，则记录日志                if (product.Price &gt;= 50)                &#123;                    logCallback(product);                &#125;                box.Product = product;                return box;            &#125;        &#125;        // 创建不同产品（Pizza和Car）的工厂类        class ProductFactory        &#123;            // 创建Pizza产品的方法            public Product MakePizza()            &#123;                Product product = new Product();                product.Name = &quot;Pizza&quot;;                product.Price = 55;                return product;            &#125;            // 创建Car产品的方法            public Product MakeCar()            &#123;                Product product = new Product();                product.Name = &quot;Car&quot;;                product.Price = 100;                return product;            &#125;        &#125;    &#125;&#125;\n\n\n\n缺点\n\n这是一种方法级别的紧耦合，现实工作中要谨慎使用\n使可读性下降，debug难度增加\n把委托回调，异步调用和多线程纠缠在一起，会让代码变得难以阅读和维护\n委托使用不当有可能造成内存泄露和程序性能下降\n\n\n委托的高级使用多播委托（multicast）示例\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WeituoPro&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Student student1 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Yellow &#125;;            Student student2 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Red &#125;;            Student student3 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Green &#125;;            Action action1 = new Action(student1.DoHomework);            Action action2 = new Action(student2.DoHomework);            Action action3 = new Action(student3.DoHomework);            action1 += action2;            action1 += action3;            action1.Invoke();\t\t\t\t\t//使用一个委托封装多个方法，多播委托，调用时执行顺序按照封装顺序执行                    \t//action1.Invoke();\t\t\t\t单播委托            //action2.Invoke();            //action3.Invoke();        &#125;                 class Student        &#123;            public int ID &#123; get; set; &#125;            public ConsoleColor PenColor &#123; get; set; &#125;            public void DoHomework()            &#123;                for (int i = 0; i &lt; 5; i++)                &#123;                    Console.ForegroundColor = this.PenColor;                    Console.WriteLine(&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;,this.ID,i);                    Task.Delay(1000).Wait();                &#125;            &#125;        &#125;    &#125;&#125;\n\n隐式异步调用同步与异步的简介中英文语言差异\n同步：你做完了（在你的基础上）我接着做\n异步：咱们两个同时做（相当于汉语中的同步进行）\n同步调用与异步调用的对比每一个运行的程序是一个进程（process）\n每个进程可以有一个或者多个进程（thread）\n同步调用是在同一线程内\n异步调用的底层机理是多线程\n串行——同步——单线程\n并行——异步——多线程\n直接同步调用就是直接调用方法，使用委托则是间接同步调用，多播委托也属于同步调用\n隐式多线程与显示多线程直接同步调用：使用方法名\n间接同步调用：使用单播&#x2F;多播委托的Invoke方法\n隐式异步调用：使用委托的BeginInvoke\n显式异步调用：使用Thread或者Task\n示例\n隐式异步调用\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WeituoPro&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Student student1 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Yellow &#125;;            Student student2 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Red &#125;;            Student student3 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Green &#125;;            Action action1 = new Action(student1.DoHomework);            Action action2 = new Action(student2.DoHomework);            Action action3 = new Action(student3.DoHomework);            action1.BeginInvoke(null, null);\t\t\t//单播隐式异步调用，但是多个线程在访问同一个资源时会发生资源冲突问题            action2.BeginInvoke(null, null);            action3.BeginInvoke(null, null);            for (int i = 0; i &lt; 5; i++)            &#123;                Console.ForegroundColor = ConsoleColor.Blue;                Console.WriteLine(&quot;test &#123;0&#125;&quot;,i);                Task.Delay(1000).Wait();            &#125;        &#125;                 class Student        &#123;            public int ID &#123; get; set; &#125;            public ConsoleColor PenColor &#123; get; set; &#125;            public void DoHomework()            &#123;                for (int i = 0; i &lt; 5; i++)                &#123;                    Console.ForegroundColor = this.PenColor;                    Console.WriteLine(&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;,this.ID,i);                    Task.Delay(1000).Wait();                &#125;            &#125;        &#125;    &#125;&#125;\n\n显式异步调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WeituoPro&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Student student1 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Yellow &#125;;            Student student2 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Red &#125;;            Student student3 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Green &#125;;            Action action1 = new Action(student1.DoHomework);            Action action2 = new Action(student2.DoHomework);            Action action3 = new Action(student3.DoHomework);            Task task1 = new Task(new Action(student1.DoHomework));            Task task2 = new Task(new Action(student2.DoHomework));            Task task3 = new Task(new Action(student3.DoHomework));            task1.Start();            task2.Start();            task3.Start();            for (int i = 0; i &lt; 5; i++)            &#123;                Console.ForegroundColor = ConsoleColor.Blue;                Console.WriteLine(&quot;test &#123;0&#125;&quot;,i);                Task.Delay(1000).Wait();            &#125;        &#125;                 class Student        &#123;            public int ID &#123; get; set; &#125;            public ConsoleColor PenColor &#123; get; set; &#125;            public void DoHomework()            &#123;                for (int i = 0; i &lt; 5; i++)                &#123;                    Console.ForegroundColor = this.PenColor;                    Console.WriteLine(&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;,this.ID,i);                    Task.Delay(1000).Wait();                &#125;            &#125;        &#125;    &#125;&#125;\n\n\n\n应该适时地使用接口（interface）取代一些对委托的使用\n\nJava完全地使用接口取代了委托的功能，即Java没有与C#中委托相对应的功能实体\n\n","slug":"weituo","date":"2023-10-28T10:13:13.000Z","categories_index":"编程","tags_index":"C#","author_index":"时雨"},{"id":"e9b6cce2ce6d201168276865751c9288","title":"参数","content":"传值，引用，数组，具名，可选参数，扩展方法\n方法参数传值参数：不带修饰符的形参，一个值形参对应一个局部变量，初始值来自该方法调用所提供的相应实参\n传值类型传进来的是一个副本，不会改变原来变量的值\n引用类型的变量存储的是一个地址，在赋值后，传值参数会得到一个新值并创建一个新的对象\n\n值参数创建变量的副本\n对值参数的操作永远不影响变量的值\n\n使用 GetHashCode()方法可以区分同名但来自不同方法的值\n\n\n引用参数：用ref修饰的形参，引用形参并不创建新的存储位置，其表示的存储位置恰是在方法中作为实参给出的变量所表示的存储位置\n\n引用参数并不创建变量的副本\n使用ref修饰符显式指出:     此方法的副作用是改变实际参数的值\n\n输出形参\n用out修饰符声明的形参是输出形参，输出形参不创建新的存储位置\n\n在方法返回前，该方法的每个输出形参都必须明确赋值\n\n用out修饰符显式指出： 此方法的副作用是通过参数向外输出值\n\nref是为了改变，out是为了输出\n\n声明带输出参数的方法\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;namespace Parser&#123; class Program &#123;     static void Main(string[] args)     &#123;         // 初始化一个 double 类型的变量 x         double x = 0;         // 尝试解析字符串 &quot;798&quot; 为 double 类型，并将结果存储在 x 中         bool b = DoubleParser.TryParse(&quot;798&quot;, out x);         // 检查解析是否成功         if (b == true)         &#123;             // 如果成功，输出解析结果加1             Console.WriteLine(x + 1);         &#125;         else         &#123;             // 如果解析失败，输出错误信息             Console.WriteLine(&quot;解析失败&quot;);         &#125;     &#125;     // 自定义 DoubleParser 类，用于解析字符串为 double 类型     class DoubleParser     &#123;         // 静态方法，尝试将输入字符串解析为 double 类型         public static bool TryParse(string input, out double result)         &#123;             try             &#123;                 // 使用 double.Parse 尝试解析字符串，并将结果赋值给 result                 result = double.Parse(input);                 return true;             &#125;             catch             &#123;                 // 如果解析失败，将 result 设为默认值 0，并返回 false                 result = 0;                 return false;             &#125;         &#125;     &#125; &#125;&#125;\n\n数组参数必需是形参列表中的最后一个，由params修饰\n举例：String.Format方法和String.Split方法\n1234567891011121314151617181920212223242526272829using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace @params&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            int result = CalculateSum(1, 2, 3);            Console.WriteLine(result);        &#125;        static int CalculateSum(params int[] intArray)        &#123;            int sum = 0;            foreach(var item in intArray)            &#123;                sum += item;            &#125;            return sum;        &#125;    &#125;&#125;\n\n\n123456789static void Main(string[] args)        &#123;            string str = &quot;tim;tom,amy.lisa&quot;;            string[] result = str.Split(&#x27;;&#x27;, &#x27;.&#x27;, &#x27;,&#x27;);            foreach (var name in result)            &#123;                Console.WriteLine(name);            &#125;        &#125;\n\n具名参数参数的位置不再受到约束\n并非参数的某个种类，而是参数的使用方法\n123456789static void Main(string[] args)        &#123;            PrintInfo(age:18, name: &quot;tim&quot;);        &#125;        static void PrintInfo(string name,int age)        &#123;            Console.WriteLine(&quot;hello&#123;0&#125;,you are &#123;1&#125;&quot;,name,age);        &#125;\n\n可选参数参数因为带有默认值而变得可选\n不推荐使用可选参数\n扩展方法（this参数）\n方法必需是公有，静态的，即被public static所修饰\n\n必需是形参列表中的第一个，由this修饰\n\n必需由一个静态类（一般类名为SomeTypeExtension）来统一收纳对SomeType类型的扩展方法\n\n举例：LINQ方法（语言集成查询）\n12345678910111213141516171819202122232425262728293031using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Linq&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            List&lt;int&gt; myList = new List&lt;int&gt;() &#123; 11, 12, 13, 14, 15 &#125;;            bool result = myList.All(i =&gt; i &gt; 10);          //All是扩展方法            Console.WriteLine(result);        &#125;        static bool AllGreaterThanTen(List&lt;int&gt;intList)        &#123;            foreach (var item in intList)            &#123;                if (item&lt;=10)                &#123;                    return false;                &#125;            &#125;            return true;        &#125;    &#125;&#125;\n\n总结\n传值参数：参数的默认传递方式\n输出参数：用于除返回值外还需要输出的场景\n引用参数：用于需要修改实际参数数值的场景\n数组参数：用于简化方法的调用\n具名参数：提高可读性\n可选参数：参数拥有默认值\n扩展方法(this参数)：为目标数据类型追加方法\n\n","slug":"canshu","date":"2023-09-28T10:13:14.000Z","categories_index":"编程","tags_index":"C#","author_index":"时雨"}]