[{"id":"9dbfb0ceb333a8d9adfdccfe0f20148d","title":"事件","content":"事件\n定义Event，事件，即 能够发生什么的什么事情\n角色事件是一种使对象或类能够提供通知的成员\n对象x拥有一个事件y ，想表达的思想是 ： 当事件y发生时，x有能力通知别的对象\n使用：用于对象或类间的动作协调与信息传递（消息推送）原理：事件模型（event model）中的两个 5发生——响应中的五个部分——闹钟响了你起床、孩子饿了你做饭。。。这里隐含这 订阅 关系\n发生——响应中的五个动作：\n\n我有一个事件\n一个人或者一群人关心我这个事件\n我的这个事件发生了\n关心这个事件的人会被依次通知到\n被通知到的人根据拿到的事件信息（又称事件数据、事件参数、通知）对事件进行响应（又称 处理事件）\n\n事件订阅者、事件参数\n提示\n事件多用于桌面、手机等开发的客户端编程、因为这些程序经常是用户通过事件来驱动的\n各种编程语言对这个机制的实现方法也不尽相同\nJava里面没有事件这种成员，也没有委托这种数据类型，Java的事件是通过接口来实现的\nMVC、MVP、MVVM等模式是事件模式更高级、更有效的玩法\n日常开发的时候，使用已有时间的机会比较多，自己声明事件的机会比较少\n事件的功能&#x3D;通知+可选的事件参数（即详细信息）\n\n\n事件的应用实例演示派生（继承）与扩展（extends）\n123456789101112131415161718192021222324252627282930313233343536using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace Event&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            // 创建 MyForm 对象            MyForm form = new MyForm();            // 订阅 Click 事件，当窗体单击时，调用 FormClicked 方法            form.Click += form.FormClicked;            // 显示窗体            form.ShowDialog();        &#125;        // 自定义窗体类，继承自 Form        class MyForm : Form        &#123;            // 事件处理方法，当窗体被单击时调用            internal void FormClicked(object sender, EventArgs e)            &#123;                // 将当前时间设置为窗体标题                this.Text = DateTime.Now.ToString();            &#125;        &#125;    &#125;&#125;\n\n\n\n事件模型的五个组成部分\n事件的拥有者（event source，对象）\n事件的成员（event ，成员）\n事件的响应者（event subscriber,对象）\n事件处理器（event handler,成员）——本质上是一个回调方法\n事件订阅器——把事件处理器与事件关联在一起，本质上是一种以委托类型为基础的“约定”\n\n注意\n事件处理器是方法成员\n挂接事件处理器的时候，可以使用委托实例，也可以直接使用方法名，这是个语法糖\n事件处理器对事件的订阅不是随意的，匹配与否声明事件时所使用的委托类型来检测\n事件可以同步调用也可以异步调用\n事件不会主动发生，一定是由事件拥有者的内部逻辑所触发的\n\n","slug":"shijian","date":"2024-01-28T13:28:20.000Z","categories_index":"编程","tags_index":"C#","author_index":"时雨"},{"id":"e9b6cce2ce6d201168276865751c9288","title":"参数","content":"传值，引用，数组，具名，可选参数，扩展方法\n方法参数传值参数：不带修饰符的形参，一个值形参对应一个局部变量，初始值来自该方法调用所提供的相应实参\n传值类型传进来的是一个副本，不会改变原来变量的值\n引用类型的变量存储的是一个地址，在赋值后，传值参数会得到一个新值并创建一个新的对象\n\n值参数创建变量的副本\n对值参数的操作永远不影响变量的值\n\n使用 GetHashCode()方法可以区分同名但来自不同方法的值\n\n\n引用参数：用ref修饰的形参，引用形参并不创建新的存储位置，其表示的存储位置恰是在方法中作为实参给出的变量所表示的存储位置\n\n引用参数并不创建变量的副本\n使用ref修饰符显式指出:     此方法的副作用是改变实际参数的值\n\n输出形参\n用out修饰符声明的形参是输出形参，输出形参不创建新的存储位置\n\n在方法返回前，该方法的每个输出形参都必须明确赋值\n\n用out修饰符显式指出： 此方法的副作用是通过参数向外输出值\n\nref是为了改变，out是为了输出\n\n声明带输出参数的方法\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;namespace Parser&#123; class Program &#123;     static void Main(string[] args)     &#123;         // 初始化一个 double 类型的变量 x         double x = 0;         // 尝试解析字符串 &quot;798&quot; 为 double 类型，并将结果存储在 x 中         bool b = DoubleParser.TryParse(&quot;798&quot;, out x);         // 检查解析是否成功         if (b == true)         &#123;             // 如果成功，输出解析结果加1             Console.WriteLine(x + 1);         &#125;         else         &#123;             // 如果解析失败，输出错误信息             Console.WriteLine(&quot;解析失败&quot;);         &#125;     &#125;     // 自定义 DoubleParser 类，用于解析字符串为 double 类型     class DoubleParser     &#123;         // 静态方法，尝试将输入字符串解析为 double 类型         public static bool TryParse(string input, out double result)         &#123;             try             &#123;                 // 使用 double.Parse 尝试解析字符串，并将结果赋值给 result                 result = double.Parse(input);                 return true;             &#125;             catch             &#123;                 // 如果解析失败，将 result 设为默认值 0，并返回 false                 result = 0;                 return false;             &#125;         &#125;     &#125; &#125;&#125;\n\n数组参数必需是形参列表中的最后一个，由params修饰\n举例：String.Format方法和String.Split方法\n1234567891011121314151617181920212223242526272829using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace @params&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            int result = CalculateSum(1, 2, 3);            Console.WriteLine(result);        &#125;        static int CalculateSum(params int[] intArray)        &#123;            int sum = 0;            foreach(var item in intArray)            &#123;                sum += item;            &#125;            return sum;        &#125;    &#125;&#125;\n\n\n123456789static void Main(string[] args)        &#123;            string str = &quot;tim;tom,amy.lisa&quot;;            string[] result = str.Split(&#x27;;&#x27;, &#x27;.&#x27;, &#x27;,&#x27;);            foreach (var name in result)            &#123;                Console.WriteLine(name);            &#125;        &#125;\n\n具名参数参数的位置不再受到约束\n并非参数的某个种类，而是参数的使用方法\n123456789static void Main(string[] args)        &#123;            PrintInfo(age:18, name: &quot;tim&quot;);        &#125;        static void PrintInfo(string name,int age)        &#123;            Console.WriteLine(&quot;hello&#123;0&#125;,you are &#123;1&#125;&quot;,name,age);        &#125;\n\n可选参数参数因为带有默认值而变得可选\n不推荐使用可选参数\n扩展方法（this参数）\n方法必需是公有，静态的，即被public static所修饰\n\n必需是形参列表中的第一个，由this修饰\n\n必需由一个静态类（一般类名为SomeTypeExtension）来统一收纳对SomeType类型的扩展方法\n\n举例：LINQ方法（语言集成查询）\n12345678910111213141516171819202122232425262728293031using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Linq&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            List&lt;int&gt; myList = new List&lt;int&gt;() &#123; 11, 12, 13, 14, 15 &#125;;            bool result = myList.All(i =&gt; i &gt; 10);          //All是扩展方法            Console.WriteLine(result);        &#125;        static bool AllGreaterThanTen(List&lt;int&gt;intList)        &#123;            foreach (var item in intList)            &#123;                if (item&lt;=10)                &#123;                    return false;                &#125;            &#125;            return true;        &#125;    &#125;&#125;\n\n总结\n传值参数：参数的默认传递方式\n输出参数：用于除返回值外还需要输出的场景\n引用参数：用于需要修改实际参数数值的场景\n数组参数：用于简化方法的调用\n具名参数：提高可读性\n可选参数：参数拥有默认值\n扩展方法(this参数)：为目标数据类型追加方法\n\n","slug":"canshu","date":"2024-01-28T10:13:14.000Z","categories_index":"编程","tags_index":"C#","author_index":"时雨"},{"id":"c31509689845d3f9a7357a64a02fc66b","title":"委托","content":"委托\n什么是委托委托（delegate）是函数指针的升级版\n一切皆地址\n\n变量（数据）是某个地址为起点的一段内存中存储的值\n函数（算法）是某个地址为起点的一段内存中所存储的一组机器语言指令\n\n直接调用与间接调用\n\n直接调用：通过函数名来调用函数，CPU通过函数名直接获得函数所在地址并开始执行——返回\n间接调用：通过函数指针来调用函数，CPU通过读取函数指针存储的值获得函数所在地址并开始执行——返回\n\nJava中没有与委托相对应的功能实体\n委托的简单使用\nAction委托\n12345678910111213141516171819202122namespace func&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Calculator calculator = new Calculator();            Action action = new Action(calculator.Report);            calculator.Report();\t\t\t\t//直接调用，不使用Action委托            action.Invoke();\t\t\t\t\t\t//使用Action委托进行间接调用            action();\t\t\t\t\t\t\t\t\t//使用Action的简便写法        &#125;        class Calculator        &#123;            public void Report()            &#123;                Console.WriteLine(&quot;hello!&quot;);            &#125;        &#125;    &#125;&#125;\n\nFunc委托\n12345678910111213141516171819202122232425262728293031323334namespace func&#123;    class Program    &#123;        static void Main(string[] args)        &#123;                   Func&lt;int, int, int&gt; func1 = new Func&lt;int, int, int&gt;(calculator.Add);\t\t//Func属于泛型            Func&lt;int, int, int&gt; func2 = new Func&lt;int, int, int&gt;(calculator.Sub);            int x = 100;            int y = 200;            int z = 0;            z = func1.Invoke(x, y);\t\t\t\t//间接调用，也可以使用上面的简便写法            Console.WriteLine(z);            z = func2.Invoke(x, y);            Console.WriteLine(z);        &#125;        class Calculator        &#123;                      public int Add(int x,int y)            &#123;                int result= x + y;                return result;            &#125;            public int Sub(int x, int y)            &#123;                int result = x - y;                return result;            &#125;        &#125;    &#125;&#125;\n\n\n\n委托的声明（自定义）委托是一种类（class），类是数据类型所以委托也是一种数据类型\n它的声明方式和一般类不同\n注意声明委托的问题\n\n避免写错地方结果声明成嵌套类型\n与program平行 ，声明在名称空间里面\n\n委托与所封装的方法必需“类型兼容”\n\n返回值的数据类型一致\n\n参数列表在个数和数据类型上一致（参数名不需要一样）\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace weituo&#123;    public delegate double Calc(double x, double y);\t\t//声明委托Calc ，double类型，两个double类型的参数      class Program    &#123;        static void Main(string[] args)        &#123;            Calculator calculator = new Calculator();            Calc calc1 = new Calc(calculator.Add);            Calc calc2 = new Calc(calculator.Sub);            double x = 100;            double y = 200;            double z = 0;            z= calc1.Invoke(x, y);            Console.WriteLine(z);            z = calc2(x, y);            Console.WriteLine(z);           //Console.WriteLine(calc1.Invoke(100, 200));           //Console.WriteLine(calc2(200, 300));                    &#125;        class Calculator        &#123;            public double Add(double x, double y)            &#123;                return x + y;            &#125;            public double Sub(double x, double y)            &#123;                return x - y;            &#125;        &#125;            &#125;&#125;\n\n委托的一般使用把方法当做参数传给另一个方法\n模板方法：借用指定外部方法来产生结果\n相当于填空题\n常位于代码中部\n委托有返回值\nReuse，复用，可以提高工作效率减少bug的引入\n示例\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using System;namespace mobanweituo&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            // 创建ProductFactory和WrapFactory的实例            ProductFactory productFactory = new ProductFactory();            WrapFactory wrapFactory = new WrapFactory();            // 定义创建不同产品（Pizza和Car）的函数            Func&lt;Product&gt; func1 = new Func&lt;Product&gt;(productFactory.MakePizza);            Func&lt;Product&gt; func2 = new Func&lt;Product&gt;(productFactory.MakeCar);            // 使用WrapFactory包装产品            Box box1 = wrapFactory.WrapProduct(func1);            Box box2 = wrapFactory.WrapProduct(func2);            // 显示盒子中产品的名称            Console.WriteLine(box1.Product.Name);            Console.WriteLine(box2.Product.Name);        &#125;        // 表示一个产品        class Product        &#123;            public string Name &#123; get; set; &#125;        &#125;        // 表示包含产品的盒子        class Box        &#123;            public Product Product &#123; get; set; &#125;        &#125;        // 用于将产品包装在盒子中的工厂，模板方法        class WrapFactory        &#123;            public Box WrapProduct(Func&lt;Product&gt; getProduct)            &#123;                // 创建一个新的盒子并将产品包装在内                Box box = new Box();                Product product = getProduct.Invoke();                box.Product = product;                return box;            &#125;         &#125;        // 用于创建不同产品（Pizza和Car）的工厂        class ProductFactory        &#123;            public Product MakePizza()            &#123;                // 创建一个Pizza产品                Product product = new Product();                product.Name = &quot;Pizza&quot;;                return product;            &#125;            public Product MakeCar()            &#123;                // 创建一个Car产品                Product product = new Product();                product.Name = &quot;Car&quot;;                return product;            &#125;        &#125;    &#125;&#125;\n\n回调（callback）方法：调用指定的外部方法相当于流水线 \n常位于代码末尾\n委托无返回值\n用委托封装一个外部方法，再通过委托传到方法内部，实现间接调用\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697using System;namespace huidiao&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            // 创建ProductFactory和WrapFactory的实例            ProductFactory productFactory = new ProductFactory();            WrapFactory wrapFactory = new WrapFactory();            // 定义创建不同产品（Pizza和Car）的函数            Func&lt;Product&gt; func1 = new Func&lt;Product&gt;(productFactory.MakePizza);            Func&lt;Product&gt; func2 = new Func&lt;Product&gt;(productFactory.MakeCar);            // 创建Logger实例            Logger logger = new Logger();            // 定义记录日志的委托            Action&lt;Product&gt; log = new Action&lt;Product&gt;(logger.Log);            // 使用WrapFactory包装产品，并在价格大于等于50时记录日志            Box box1 = wrapFactory.WrapProduct(func1, log);            Box box2 = wrapFactory.WrapProduct(func2, log);            // 显示盒子中产品的名称            Console.WriteLine(box1.Product.Name);            Console.WriteLine(box2.Product.Name);        &#125;        // 日志记录器类        class Logger        &#123;            // 记录产品日志的方法            public void Log(Product product)            &#123;                Console.WriteLine(&quot;产品&#x27;&#123;0&#125;&#x27;在 &#123;1&#125; 创建。价格为 &#123;2&#125;&quot;, product.Name, DateTime.UtcNow, product.Price);            &#125;        &#125;        // 产品类        class Product        &#123;            public string Name &#123; get; set; &#125;            public double Price &#123; get; set; &#125;        &#125;        // 包含产品的盒子类        class Box        &#123;            public Product Product &#123; get; set; &#125;        &#125;        // 将产品包装在盒子中的工厂类        class WrapFactory        &#123;            // 包装产品并在价格大于等于50时触发日志回调            public Box WrapProduct(Func&lt;Product&gt; getProduct, Action&lt;Product&gt; logCallback)            &#123;                Box box = new Box();                Product product = getProduct.Invoke();                                // 如果产品的价格大于等于50，则记录日志                if (product.Price &gt;= 50)                &#123;                    logCallback(product);                &#125;                box.Product = product;                return box;            &#125;        &#125;        // 创建不同产品（Pizza和Car）的工厂类        class ProductFactory        &#123;            // 创建Pizza产品的方法            public Product MakePizza()            &#123;                Product product = new Product();                product.Name = &quot;Pizza&quot;;                product.Price = 55;                return product;            &#125;            // 创建Car产品的方法            public Product MakeCar()            &#123;                Product product = new Product();                product.Name = &quot;Car&quot;;                product.Price = 100;                return product;            &#125;        &#125;    &#125;&#125;\n\n\n\n缺点\n\n这是一种方法级别的紧耦合，现实工作中要谨慎使用\n使可读性下降，debug难度增加\n把委托回调，异步调用和多线程纠缠在一起，会让代码变得难以阅读和维护\n委托使用不当有可能造成内存泄露和程序性能下降\n\n\n委托的高级使用多播委托（multicast）示例\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WeituoPro&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Student student1 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Yellow &#125;;            Student student2 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Red &#125;;            Student student3 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Green &#125;;            Action action1 = new Action(student1.DoHomework);            Action action2 = new Action(student2.DoHomework);            Action action3 = new Action(student3.DoHomework);            action1 += action2;            action1 += action3;            action1.Invoke();\t\t\t\t\t//使用一个委托封装多个方法，多播委托，调用时执行顺序按照封装顺序执行                    \t//action1.Invoke();\t\t\t\t单播委托            //action2.Invoke();            //action3.Invoke();        &#125;                 class Student        &#123;            public int ID &#123; get; set; &#125;            public ConsoleColor PenColor &#123; get; set; &#125;            public void DoHomework()            &#123;                for (int i = 0; i &lt; 5; i++)                &#123;                    Console.ForegroundColor = this.PenColor;                    Console.WriteLine(&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;,this.ID,i);                    Task.Delay(1000).Wait();                &#125;            &#125;        &#125;    &#125;&#125;\n\n隐式异步调用同步与异步的简介中英文语言差异\n同步：你做完了（在你的基础上）我接着做\n异步：咱们两个同时做（相当于汉语中的同步进行）\n同步调用与异步调用的对比每一个运行的程序是一个进程（process）\n每个进程可以有一个或者多个进程（thread）\n同步调用是在同一线程内\n异步调用的底层机理是多线程\n串行——同步——单线程\n并行——异步——多线程\n直接同步调用就是直接调用方法，使用委托则是间接同步调用，多播委托也属于同步调用\n隐式多线程与显示多线程直接同步调用：使用方法名\n间接同步调用：使用单播&#x2F;多播委托的Invoke方法\n隐式异步调用：使用委托的BeginInvoke\n显式异步调用：使用Thread或者Task\n示例\n隐式异步调用\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WeituoPro&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Student student1 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Yellow &#125;;            Student student2 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Red &#125;;            Student student3 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Green &#125;;            Action action1 = new Action(student1.DoHomework);            Action action2 = new Action(student2.DoHomework);            Action action3 = new Action(student3.DoHomework);            action1.BeginInvoke(null, null);\t\t\t//单播隐式异步调用，但是多个线程在访问同一个资源时会发生资源冲突问题            action2.BeginInvoke(null, null);            action3.BeginInvoke(null, null);            for (int i = 0; i &lt; 5; i++)            &#123;                Console.ForegroundColor = ConsoleColor.Blue;                Console.WriteLine(&quot;test &#123;0&#125;&quot;,i);                Task.Delay(1000).Wait();            &#125;        &#125;                 class Student        &#123;            public int ID &#123; get; set; &#125;            public ConsoleColor PenColor &#123; get; set; &#125;            public void DoHomework()            &#123;                for (int i = 0; i &lt; 5; i++)                &#123;                    Console.ForegroundColor = this.PenColor;                    Console.WriteLine(&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;,this.ID,i);                    Task.Delay(1000).Wait();                &#125;            &#125;        &#125;    &#125;&#125;\n\n显式异步调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WeituoPro&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Student student1 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Yellow &#125;;            Student student2 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Red &#125;;            Student student3 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Green &#125;;            Action action1 = new Action(student1.DoHomework);            Action action2 = new Action(student2.DoHomework);            Action action3 = new Action(student3.DoHomework);            Task task1 = new Task(new Action(student1.DoHomework));            Task task2 = new Task(new Action(student2.DoHomework));            Task task3 = new Task(new Action(student3.DoHomework));            task1.Start();            task2.Start();            task3.Start();            for (int i = 0; i &lt; 5; i++)            &#123;                Console.ForegroundColor = ConsoleColor.Blue;                Console.WriteLine(&quot;test &#123;0&#125;&quot;,i);                Task.Delay(1000).Wait();            &#125;        &#125;                 class Student        &#123;            public int ID &#123; get; set; &#125;            public ConsoleColor PenColor &#123; get; set; &#125;            public void DoHomework()            &#123;                for (int i = 0; i &lt; 5; i++)                &#123;                    Console.ForegroundColor = this.PenColor;                    Console.WriteLine(&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;,this.ID,i);                    Task.Delay(1000).Wait();                &#125;            &#125;        &#125;    &#125;&#125;\n\n\n\n应该适时地使用接口（interface）取代一些对委托的使用\n\nJava完全地使用接口取代了委托的功能，即Java没有与C#中委托相对应的功能实体\n\n","slug":"weituo","date":"2024-01-28T10:13:13.000Z","categories_index":"编程","tags_index":"C#","author_index":"时雨"}]