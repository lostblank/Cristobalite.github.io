[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"委托\n什么是委托\n\n委托（delegate）是函数指针的升级版\n\n一切皆地址\n\n变量（数据）是某个地址为起点的一段内存中存储的值\n函数（算法）是某个地址为起点的一段内存中所存储的一组机器语言指令\n\n\n直接调用与间接调用\n\n直接调用：通过函数名来调用函数，CPU通过函数名直接获得函数所在地址并开始执行——返回\n间接调用：通过函数指针来调用函数，CPU通过读取函数指针存储的值获得函数所在地址并开始执行——返回\n\n\nJava中没有与委托相对应的功能实体\n\n委托的简单使用\n\nAction委托\n12345678910111213141516171819202122namespace func&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Calculator calculator = new Calculator();            Action action = new Action(calculator.Report);            calculator.Report();\t\t\t\t//直接调用，不使用Action委托            action.Invoke();\t\t\t\t\t\t//使用Action委托进行间接调用            action();\t\t\t\t\t\t\t\t\t//使用Action的简便写法        &#125;        class Calculator        &#123;            public void Report()            &#123;                Console.WriteLine(&quot;hello!&quot;);            &#125;        &#125;    &#125;&#125;\n\nFunc委托\n12345678910111213141516171819202122232425262728293031323334namespace func&#123;    class Program    &#123;        static void Main(string[] args)        &#123;                   Func&lt;int, int, int&gt; func1 = new Func&lt;int, int, int&gt;(calculator.Add);\t\t//Func属于泛型            Func&lt;int, int, int&gt; func2 = new Func&lt;int, int, int&gt;(calculator.Sub);            int x = 100;            int y = 200;            int z = 0;            z = func1.Invoke(x, y);\t\t\t\t//间接调用，也可以使用上面的简便写法            Console.WriteLine(z);            z = func2.Invoke(x, y);            Console.WriteLine(z);        &#125;        class Calculator        &#123;                      public int Add(int x,int y)            &#123;                int result= x + y;                return result;            &#125;            public int Sub(int x, int y)            &#123;                int result = x - y;                return result;            &#125;        &#125;    &#125;&#125;\n\n\n\n\n委托的声明（自定义）\n\n委托是一种类（class），类是数据类型所以委托也是一种数据类型\n\n它的声明方式和一般类不同\n\n注意声明委托的问题\n\n避免写错地方结果声明成嵌套类型\n与program平行 ，声明在名称空间里面\n\n\n委托与所封装的方法必需“类型兼容”\n\n返回值的数据类型一致\n参数列表在个数和数据类型上一致（参数名不需要一样）\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace weituo&#123;    public delegate double Calc(double x, double y);\t\t//声明委托Calc ，double类型，两个double类型的参数      class Program    &#123;        static void Main(string[] args)        &#123;            Calculator calculator = new Calculator();            Calc calc1 = new Calc(calculator.Add);            Calc calc2 = new Calc(calculator.Sub);            double x = 100;            double y = 200;            double z = 0;            z= calc1.Invoke(x, y);            Console.WriteLine(z);            z = calc2(x, y);            Console.WriteLine(z);           //Console.WriteLine(calc1.Invoke(100, 200));           //Console.WriteLine(calc2(200, 300));                    &#125;        class Calculator        &#123;            public double Add(double x, double y)            &#123;                return x + y;            &#125;            public double Sub(double x, double y)            &#123;                return x - y;            &#125;        &#125;            &#125;&#125;\n\n\n委托的一般使用\n\n把方法当做参数传给另一个方法\n模板方法：借用指定外部方法来产生结果\n\n相当于填空题\n\n常位于代码中部\n\n委托有返回值\n\nReuse，复用，可以提高工作效率减少bug的引入\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using System;namespace mobanweituo&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            // 创建ProductFactory和WrapFactory的实例            ProductFactory productFactory = new ProductFactory();            WrapFactory wrapFactory = new WrapFactory();            // 定义创建不同产品（Pizza和Car）的函数            Func&lt;Product&gt; func1 = new Func&lt;Product&gt;(productFactory.MakePizza);            Func&lt;Product&gt; func2 = new Func&lt;Product&gt;(productFactory.MakeCar);            // 使用WrapFactory包装产品            Box box1 = wrapFactory.WrapProduct(func1);            Box box2 = wrapFactory.WrapProduct(func2);            // 显示盒子中产品的名称            Console.WriteLine(box1.Product.Name);            Console.WriteLine(box2.Product.Name);        &#125;        // 表示一个产品        class Product        &#123;            public string Name &#123; get; set; &#125;        &#125;        // 表示包含产品的盒子        class Box        &#123;            public Product Product &#123; get; set; &#125;        &#125;        // 用于将产品包装在盒子中的工厂，模板方法        class WrapFactory        &#123;            public Box WrapProduct(Func&lt;Product&gt; getProduct)            &#123;                // 创建一个新的盒子并将产品包装在内                Box box = new Box();                Product product = getProduct.Invoke();                box.Product = product;                return box;            &#125;         &#125;        // 用于创建不同产品（Pizza和Car）的工厂        class ProductFactory        &#123;            public Product MakePizza()            &#123;                // 创建一个Pizza产品                Product product = new Product();                product.Name = &quot;Pizza&quot;;                return product;            &#125;            public Product MakeCar()            &#123;                // 创建一个Car产品                Product product = new Product();                product.Name = &quot;Car&quot;;                return product;            &#125;        &#125;    &#125;&#125;\n\n\n回调（callback）方法：调用指定的外部方法\n\n相当于流水线 \n\n常位于代码末尾\n\n委托无返回值\n\n用委托封装一个外部方法，再通过委托传到方法内部，实现间接调用\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697using System;namespace huidiao&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            // 创建ProductFactory和WrapFactory的实例            ProductFactory productFactory = new ProductFactory();            WrapFactory wrapFactory = new WrapFactory();            // 定义创建不同产品（Pizza和Car）的函数            Func&lt;Product&gt; func1 = new Func&lt;Product&gt;(productFactory.MakePizza);            Func&lt;Product&gt; func2 = new Func&lt;Product&gt;(productFactory.MakeCar);            // 创建Logger实例            Logger logger = new Logger();            // 定义记录日志的委托            Action&lt;Product&gt; log = new Action&lt;Product&gt;(logger.Log);            // 使用WrapFactory包装产品，并在价格大于等于50时记录日志            Box box1 = wrapFactory.WrapProduct(func1, log);            Box box2 = wrapFactory.WrapProduct(func2, log);            // 显示盒子中产品的名称            Console.WriteLine(box1.Product.Name);            Console.WriteLine(box2.Product.Name);        &#125;        // 日志记录器类        class Logger        &#123;            // 记录产品日志的方法            public void Log(Product product)            &#123;                Console.WriteLine(&quot;产品&#x27;&#123;0&#125;&#x27;在 &#123;1&#125; 创建。价格为 &#123;2&#125;&quot;, product.Name, DateTime.UtcNow, product.Price);            &#125;        &#125;        // 产品类        class Product        &#123;            public string Name &#123; get; set; &#125;            public double Price &#123; get; set; &#125;        &#125;        // 包含产品的盒子类        class Box        &#123;            public Product Product &#123; get; set; &#125;        &#125;        // 将产品包装在盒子中的工厂类        class WrapFactory        &#123;            // 包装产品并在价格大于等于50时触发日志回调            public Box WrapProduct(Func&lt;Product&gt; getProduct, Action&lt;Product&gt; logCallback)            &#123;                Box box = new Box();                Product product = getProduct.Invoke();                                // 如果产品的价格大于等于50，则记录日志                if (product.Price &gt;= 50)                &#123;                    logCallback(product);                &#125;                box.Product = product;                return box;            &#125;        &#125;        // 创建不同产品（Pizza和Car）的工厂类        class ProductFactory        &#123;            // 创建Pizza产品的方法            public Product MakePizza()            &#123;                Product product = new Product();                product.Name = &quot;Pizza&quot;;                product.Price = 55;                return product;            &#125;            // 创建Car产品的方法            public Product MakeCar()            &#123;                Product product = new Product();                product.Name = &quot;Car&quot;;                product.Price = 100;                return product;            &#125;        &#125;    &#125;&#125;\n\n\n缺点\n\n这是一种方法级别的紧耦合，现实工作中要谨慎使用\n使可读性下降，debug难度增加\n把委托回调，异步调用和多线程纠缠在一起，会让代码变得难以阅读和维护\n委托使用不当有可能造成内存泄露和程序性能下降\n\n\n\n\n\n委托的高级使用\n多播委托（multicast）\n\n示例\n\n\n   1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WeituoPro&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Student student1 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Yellow &#125;;            Student student2 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Red &#125;;            Student student3 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Green &#125;;            Action action1 = new Action(student1.DoHomework);            Action action2 = new Action(student2.DoHomework);            Action action3 = new Action(student3.DoHomework);            action1 += action2;            action1 += action3;            action1.Invoke();\t\t\t\t\t//使用一个委托封装多个方法，多播委托，调用时执行顺序按照封装顺序执行                    \t//action1.Invoke();\t\t\t\t单播委托            //action2.Invoke();            //action3.Invoke();        &#125;                 class Student        &#123;            public int ID &#123; get; set; &#125;            public ConsoleColor PenColor &#123; get; set; &#125;            public void DoHomework()            &#123;                for (int i = 0; i &lt; 5; i++)                &#123;                    Console.ForegroundColor = this.PenColor;                    Console.WriteLine(&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;,this.ID,i);                    Task.Delay(1000).Wait();                &#125;            &#125;        &#125;    &#125;&#125;\n\n隐式异步调用\n\n同步与异步的简介\n\n中英文语言差异\n同步：你做完了（在你的基础上）我接着做\n异步：咱们两个同时做（相当于汉语中的同步进行）\n\n\n同步调用与异步调用的对比\n\n每一个运行的程序是一个进程（process）\n每个进程可以有一个或者多个进程（thread）\n同步调用是在同一线程内\n异步调用的底层机理是多线程\n串行——同步——单线程\n并行——异步——多线程\n直接同步调用就是直接调用方法，使用委托则是间接同步调用，多播委托也属于同步调用\n\n\n隐式多线程与显示多线程\n\n直接同步调用：使用方法名\n\n间接同步调用：使用单播&#x2F;多播委托的Invoke方法\n\n隐式异步调用：使用委托的BeginInvoke\n\n显式异步调用：使用Thread或者Task\n\n示例\n\n隐式异步调用\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WeituoPro&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Student student1 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Yellow &#125;;            Student student2 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Red &#125;;            Student student3 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Green &#125;;            Action action1 = new Action(student1.DoHomework);            Action action2 = new Action(student2.DoHomework);            Action action3 = new Action(student3.DoHomework);            action1.BeginInvoke(null, null);\t\t\t//单播隐式异步调用，但是多个线程在访问同一个资源时会发生资源冲突问题            action2.BeginInvoke(null, null);            action3.BeginInvoke(null, null);            for (int i = 0; i &lt; 5; i++)            &#123;                Console.ForegroundColor = ConsoleColor.Blue;                Console.WriteLine(&quot;test &#123;0&#125;&quot;,i);                Task.Delay(1000).Wait();            &#125;        &#125;                 class Student        &#123;            public int ID &#123; get; set; &#125;            public ConsoleColor PenColor &#123; get; set; &#125;            public void DoHomework()            &#123;                for (int i = 0; i &lt; 5; i++)                &#123;                    Console.ForegroundColor = this.PenColor;                    Console.WriteLine(&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;,this.ID,i);                    Task.Delay(1000).Wait();                &#125;            &#125;        &#125;    &#125;&#125;\n\n显式异步调用\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace WeituoPro&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Student student1 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Yellow &#125;;            Student student2 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Red &#125;;            Student student3 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Green &#125;;            Action action1 = new Action(student1.DoHomework);            Action action2 = new Action(student2.DoHomework);            Action action3 = new Action(student3.DoHomework);            Task task1 = new Task(new Action(student1.DoHomework));            Task task2 = new Task(new Action(student2.DoHomework));            Task task3 = new Task(new Action(student3.DoHomework));            task1.Start();            task2.Start();            task3.Start();            for (int i = 0; i &lt; 5; i++)            &#123;                Console.ForegroundColor = ConsoleColor.Blue;                Console.WriteLine(&quot;test &#123;0&#125;&quot;,i);                Task.Delay(1000).Wait();            &#125;        &#125;                 class Student        &#123;            public int ID &#123; get; set; &#125;            public ConsoleColor PenColor &#123; get; set; &#125;            public void DoHomework()            &#123;                for (int i = 0; i &lt; 5; i++)                &#123;                    Console.ForegroundColor = this.PenColor;                    Console.WriteLine(&quot;Student&#123;0&#125; doing homework &#123;1&#125; hour(s)&quot;,this.ID,i);                    Task.Delay(1000).Wait();                &#125;            &#125;        &#125;    &#125;&#125;\n\n\n\n\n应该适时地使用接口（interface）取代一些对委托的使用\n\nJava完全地使用接口取代了委托的功能，即Java没有与C#中委托相对应的功能实体\n\n\n\n\n\n","slug":"weituo","date":"2024-01-28T14:38:50.982Z","categories_index":"","tags_index":"","author_index":"时雨"},{"id":"9dbfb0ceb333a8d9adfdccfe0f20148d","title":"事件","content":"事件\n定义\nEvent，事件，即 能够发生什么的什么事情\n\n\n角色\n事件是一种使对象或类能够提供通知的成员\n对象x拥有一个事件y ，想表达的思想是 ： 当事件y发生时，x有能力通知别的对象\n\n\n使用：用于对象或类间的动作协调与信息传递（消息推送）\n原理：事件模型（event model）中的两个 5\n发生——响应中的五个部分——闹钟响了你起床、孩子饿了你做饭。。。这里隐含这 订阅 关系\n发生——响应中的五个动作：\n我有一个事件\n一个人或者一群人关心我这个事件\n我的这个事件发生了\n关心这个事件的人会被依次通知到\n被通知到的人根据拿到的事件信息（又称事件数据、事件参数、通知）对事件进行响应（又称 处理事件）\n\n\n事件订阅者、事件参数\n\n\n提示\n事件多用于桌面、手机等开发的客户端编程、因为这些程序经常是用户通过事件来驱动的\n各种编程语言对这个机制的实现方法也不尽相同\nJava里面没有事件这种成员，也没有委托这种数据类型，Java的事件是通过接口来实现的\nMVC、MVP、MVVM等模式是事件模式更高级、更有效的玩法\n日常开发的时候，使用已有时间的机会比较多，自己声明事件的机会比较少\n事件的功能&#x3D;通知+可选的事件参数（即详细信息）\n\n\n\n","slug":"shijian","date":"2024-01-28T13:28:20.000Z","categories_index":"","tags_index":"","author_index":"时雨"},{"id":"bc567916c4dc0d8169bd26d18e348d36","title":"test","content":"HelloWorld详解代码\n1234567891011121314151617using System;\t\t\t\t\t\t\t\t\t\t\t\t\t\t//从名称空间中引用到程序里面，using关键字为引用，后面为名称空间using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ConsoleApp1\t\t\t\t//名称空间&#123;    class Program\t\t\t\t\t//类    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;HelloWorld&quot;);\t\t//WriteLine也是类，作用为输出，Console也是类来自名称空间System        &#125;    &#125;&#125;\n\n","slug":"test","date":"2024-01-28T10:13:13.000Z","categories_index":"","tags_index":"","author_index":"时雨"}]